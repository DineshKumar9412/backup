Python Document

                   Python latest version 3.10.4

Why We Want to Learn?
* Data Analysis and Processing
* Artificial Intelligence
* Games
* Hardware/Sensor/Robots
* Desktop Applications

Desktop GUI Applications?

* Tkinter or Tk
* wxWidgetM
* Kivy (used for writing multitouch applications )
* PyQt or Pyside

Python Variables?
	Variable is a name that is used to refer to memory location. Python variable is also known as an identifier and used to hold value.
Camel Case
	For example - nameOfStudent, valueOfVaraible, etc
Pascal Case
	For example - NameOfStudent, etc
Snake Case
	For example - name_of_student, etc

Python Variable Types?
	Â Local variable and Global variable

Python Data Types?
str
int,Â float,Â complex
list,Â tuple,Â range
dict
set,Â frozenset
bool
bytes,Â bytearray,Â memoryview
NoneType

Python Strings?

	Strings indexing 
	a = â€œHelloâ€
	print(a[0])    ==>indexing

	splitting
	strÂ =Â "JAVATPOINT"Â Â 
	print(str[0:])Â Â = JAVATPOINT  |   print(str[1:5]) == AVAT   |     print(str[2:4])Â  ==Â VA     |    print(str[:3])Â Â == JAV                       ==>splitting
	
	Modify Strings
	a = "Hello, World!"
	print(a.upper())
	
	strip And Split
	strip only removes whitespace
	X="  Hello World!   â€
	print(x.strip())        ==     Hello World!
	Split
	# Splitting at ':'  word = 'geeks:for:geeks'  print(word.split(':'))Â Â ==>  [â€˜geeks', 'for', 'geeksâ€™]         | # Splitting at t   word = 'CatBatSatFatOr'  print(word.split('t'))  ==> ['Ca', 'Ba', 'Sa', 'Fa', 'Or']

	The format() method
		print("{}Â andÂ {}Â bothÂ areÂ theÂ bestÂ friend".format("Devansh","Abhishek"))Â Â 
		print("{1}Â andÂ {0}Â bestÂ playersÂ ".format("Virat","Rohit"))Â Â 
		print("{a},{b},{c}".format(aÂ =Â "James",Â bÂ =Â "Peter",Â cÂ =Â "Ricky"))Â Â 

Python Operators
* Arithmetic operators.Â             + - / * %
* Comparison operators.Â          ==Â  != <= >=Â  < >
* Assignment OperatorsÂ           =Â  +=Â  -=Â  *=
* Logical OperatorsÂ                  andÂ  or not
* Bitwise Operators                   &Â  |Â 
* Membership OperatorsÂ          inÂ  not in
* Identity OperatorsÂ                  isÂ  is notâ€¨
Difference Between List, Tuple Set and Dictionary 

Collection VS Features	Mutable	Ordered	Indexing	Duplicate Data
List	âœ”	âœ”	âœ”	âœ”
Tuple	ğ„‚	âœ”	âœ”	âœ”
Set	âœ”	ğ„‚	ğ„‚	ğ„‚
Dictionary	âœ”	âœ”	âœ”	ğ„‚

Ordered means how many times we print that it will print only order 
A = [1 , 2, 'abc', 3, 'def']
Print(A)     ===>  use this print every time print the same order but set some times the order will differed

Mutable we can able to change the index posiction 
tuple1 = (0, 1, 2, 3)Â     tuple1[0] = 4      print(tuple1)     ====> error
list = [0,2,3,5]  list[0]= 8    print(list)  ===> [8,2,3,5]

Indexing
tuples, list, dictionary ==> a = [1, 2, 4, 6]     print(a[0]) ===>  1
set      ==> error

Duplicate Data
List and tuples = [1,2,3,2,4,1]      its working print(a) ===> [1,2,3,2,4,1]
Set	= {1,2,4,5,1,2,4}      ====> its print(a)    ===> {1,2,4,5}
Dict     ===>    Ordered collection in Python version 3.7, unordered in Python Version=3.6

List	
New Items in a list can be added using the append() method

Method	Description
append()	Adds an element at the end of the list
clear()	Removes all the elements from the list
copy()	Returns a copy of the list
count()	Returns the number of elements with the specified value
extend()	Add the elements of a list (or any iterable), to the end of the current list
index()	Returns the index of the first element with the specified value
insert()	Adds an element at the specified position
pop()	Removes the element at the specified position
remove()	Removes the item with the specified value
reverse()	Reverses the order of the list
sort()	Sorts the list

Tuples
No
Method	Description
count()	Returns the number of times a specified value occurs in a tuple
index()	Searches the tuple for a specified value and returns the position of where it was found
Set	

ethod	Description
add()	Adds an element to the set
clear()	Removes all the elements from the set
copy()	Returns a copy of the set
difference()	Returns a set containing the difference between two or more sets
difference_update()	Removes the items in this set that are also included in another, specified set
discard()	Remove the specified item
intersection()	Returns a set, that is the intersection of two other sets
intersection_update()	Removes the items in this set that are not present in other, specified set(s)
isdisjoint()	Returns whether two sets have a intersection or not
issubset()	Returns whether another set contains this set or not
issuperset()	Returns whether this set contains another set or not
pop()	Removes an element from the set
remove()	Removes the specified element
symmetric_difference()	Returns a set with the symmetric differences of two sets
symmetric_difference_update()	inserts the symmetric differences from this set and another
union()	Return a set containing the union of sets
update()	Update the set with the union of this set and others
Dist

Method	Description
clear()	Removes all the elements from the dictionary
copy()	Returns a copy of the dictionary
fromkeys()	Returns a dictionary with the specified keys and value
get()	Returns the value of the specified key
items()	Returns a list containing a tuple for each key value pair
keys()	Returns a list containing the dictionary's keys
pop()	Removes the element with the specified key
popitem()	Removes the last inserted key-value pair
setdefault()	Returns the value of the specified key. If the key does not exist: insert the key, with the specified value
update()	Updates the dictionary with the specified key-value pairs
values()	Returns a list of all the values in the dictionary


LIST VS TUPLES
*******************
Tuples are immutable	
Implication of iterations is Time-consuming	The implication of iterations is comparatively Faster
The list is better for performing operations, such as insertion and deletion.	Tuple data type is appropriate for accessing the elements
Lists consume more memory	Tuple consume less memory as compared to the list
Lists have several built-in methods	Tuple does not have many built-in methods.
The unexpected changes and errors are more likely to occur	In tuple, it is hard to take place.

Function 

Types of arguments
1. Required arguments
2. Keyword arguments
3. Default arguments
4. Variable-length arguments

Required Arguments
**********************
defÂ func(name):Â Â Â Â     #name is Required Arguments
Â Â Â Â messageÂ =Â "HiÂ "+nameÂ Â 
Â Â Â Â returnÂ messageÂ Â 
nameÂ =Â input("EnterÂ theÂ name:")Â Â Â Â 
print(func(name))Â Â Â Â 

Dafault arguments
********************
defÂ printme(name,age=22):Â Â Â Â  # We give the value age =22 Dafault arguments
Â Â Â Â print("MyÂ nameÂ is",name,"andÂ ageÂ is",age)Â Â Â Â 
printme(nameÂ =Â "john")Â 

Variable-length Arguments (*args)
*************************************
defÂ printme(*names):Â Â Â Â Â We using *name mean multiple value Variable-length Arguments
Â Â Â Â print("printingÂ theÂ passedÂ arguments...")Â Â Â Â 
Â Â Â Â forÂ nameÂ inÂ names:Â Â Â Â 
Â Â Â Â Â Â Â Â print(name)Â Â Â Â 
printme("john","David","smith","nick")Â Â Â Â 

Keyword arguments
**********************
defÂ func(name,message):Â Â Â Â 
Â Â Â Â print("printingÂ theÂ messageÂ with",name,"andÂ ",message)Â Â Â Â 
Â Â Â Â func(nameÂ =Â "John",message="hello")Â Â Â #  we give key and value Keyword arguments

Python Built-in Functions
****************************
sÂ =Â sum([1,Â 2,2Â ])Â Â  5
Len() Float() list() open() print() reversed()  range() round() str() tuple() type() dir() enumerate()
Dict() min() set() slice() sorted() input() int() help()
eval()
xÂ =Â 5Â Â 
print(eval('xÂ +Â 1'))Â Â 

Python Lambda Functions
************************
lambdaÂ arguments:Â expressionÂ Â 

xÂ =Â lambdaÂ a:a+10Â 
print(x(20))Â Â 

Give Another Way
df = (lambda x: x*4)(3)
print(df)

Python Lambda function is known as the anonymous function that is defined without a name

showing difference between def() and lambda()

def()
def cube(y):
	return y*y*y
print(cube(5))
Lamda
lambda_cube = lambda y: y*y*y
print(lambda_cube(5))
EX:
x =Â lambdaÂ a, b, c : a + b + c
print(x(5,Â 6,Â 2))
Function with lama
defÂ myfunc(n):
Â Â returnÂ lambdaÂ a : a * n
mydoubler = myfunc(2)
print(mydoubler(11))
If else
vm = 78
nwe = (lambda v: "biggest" if (v > 80) else "yes")(vm)
print(nwe)
Filter with Lamda
# Program to filter out only the even items from a list
my_list = [1, 5, 4, 6, 8, 11, 3, 12]
new_list = list(filter(lambda x: (x%2 == 0) , my_list))
print(new_list)
Filter with Map
# Program to double each item in a list using map()
my_list = [1, 5, 4, 6, 8, 11, 3, 12]
new_list = list(map(lambda x: x * 2 , my_list))
print(new_list)

Python Filters Functions
***************************
filterÂ (function,Â iterable)Â Â 

def fun(variable):
	letters = ['a', 'e', 'i', 'o', 'u']
	if (variable in letters):
		return True
	else:
		return False
sequence = ['g', 'e', 'e', 'j', 'k', 's', 'p', 'r']
filtered = filter(fun, sequence)
for s in filtered:
	print(s)
Lamda
seq = [0, 1, 2, 3, 5, 8, 13]
result = filter(lambda x: x % 2 != 0, seq)
print(list(result))

Python Map Functions
************************
def addition(n):
	return n + n
numbers = (1, 2, 3, 4)
result = map(addition, numbers)
print(list(result))
Lamda
numbers = (1, 2, 3, 4)
result = map(lambda x: x + x, numbers)
print(list(result))

Python difference between filter() and map()
*********************************************
As per my understanding below are the difference between map and filter:
def even(num):
    if(num % 2 == 0):
        return 'Even'
num_list = [1,2,3,4,5]
print(list(filter(even,num_list))) ->>>>>>>output: [2, 4]
print(list(map(even,num_list))) ->>>>>>> output: [None, 'Even', None, 'Even', None]

Python File Handling
**********************
* Open a file
* Read or write - Performing operation
* Close the file

Python Modules
*********************
A python module can be defined as a python program file which contains a python code including python functions, class, or variables. In other words, we can say that our python code file saved with the extension (.py) is treated as the module. We may have a runnable code inside the python module

Ex:
calculation.py
defÂ summation(a,b):Â Â 
Â Â Â Â returnÂ a+bÂ Â 
Main.py
fromÂ calculationÂ importÂ summationÂ Â Â Â 
aÂ =Â int(input("EnterÂ theÂ firstÂ number"))Â Â 
bÂ =Â int(input("EnterÂ theÂ secondÂ number"))Â Â 
print("SumÂ =Â ",summation(a,b))

fromÂ <module>Â importÂ *Â Â Â 
importÂ <module-name>Â asÂ <specific-name>Â Â Â 

Python __init__.py(https://www.youtube.com/watch?v=wMTO8K1kG7Y)

Python 3.2.0 blow only we use this      The __init__ method isÂ the Python equivalent of the C++ constructor in an object-oriented approach

1st ===>       We need to create	a folder name   Employee	
2nd ===>     in that Employee folder we create a two  python file  calculate.py      and      __init__.py
3rd ===>      create a functions link blow

In that  calculate.py
defÂ getITNames():Â Â 
Â Â Â Â ListÂ =Â ["John",Â "David",Â "Nick",Â Â Â Â "Martin"]Â Â 
Â Â Â Â returnÂ List;Â Â 

In that  __init__.py 
from  calculate  importÂ getITNamesÂ Â 

Now, the directoryÂ EmployeesÂ has become the package containing two python modules

Python Exception
*******************
try:
Â Â print(x)
except:
Â Â print("Something went wrong")
finally:
Â Â print("The 'try except' is finished")

Python Date and time
***********************
* dateÂ - It is a naive ideal date. It consists of the year, month, and day as attributes.
* timeÂ - It is a perfect time, assuming every day has precisely 24*60*60 seconds. It has hour, minute, second, microsecond, andÂ tzinfoÂ as attributes.
* datetimeÂ - It is a grouping of date and time, along with the attributes year, month, day, hour, minute, second, microsecond, and tzinfo.
* timedelta -Â It represents the difference between two dates, time or datetime instances to microsecond resolution.
* tzinfoÂ - It provides time zone information objects.
* timezone -Â It is included in the new version of Python. It is the class that implements theÂ tzinfoÂ abstract base class.

importÂ time print(time.time())

importÂ datetimeÂ Â 
print(datetime.datetime.now())Â Â Â Â 

importÂ calendar;Â Â Â Â 
calÂ =Â calendar.month(2020,3)Â Â Â Â 
print(cal)Â 

importÂ calendarÂ Â Â Â 
sÂ =Â calendar.prcal(2020)

Python Regular Expressions
******************************
Function	Description
match	This method matches the regex pattern in the string with the optional flag. It returns true if a match is found in the string otherwise it returns false.
search	This method returns the match object if there is a match found in the string.
findall	It returns a list that contains all the matches of a pattern in the string.
split	Returns a list in which the string has been split in each match.
sub	Replace one or many matches in the string.

importÂ reÂ Â 
strÂ =Â "HowÂ areÂ you.Â HowÂ isÂ everything"Â Â 
matchesÂ =Â re.findall("How",Â str)Â Â 
print(matches)Â Â 

Python Sending Email using SMTP
Â Â 
importÂ smtplibÂ Â Â Â 
sender_mailÂ =Â 'sender@fromdomain.com'Â Â Â Â 
receivers_mailÂ =Â ['reciever@todomain.com']Â Â Â Â 
messageÂ =Â """From:Â FromÂ PersonÂ %sÂ Â 
To:Â ToÂ PersonÂ %sÂ Â 
Subject:Â SendingÂ SMTPÂ e-mailÂ Â Â 
ThisÂ isÂ aÂ testÂ e-mailÂ message.Â Â 
"""%(sender_mail,receivers_mail)Â Â Â Â 
try:Â Â Â Â 
Â Â Â smtpObjÂ =Â smtplib.SMTP('localhost')Â Â Â Â 
Â Â Â smtpObj.sendmail(sender_mail,Â receivers_mail,Â message)Â Â Â Â 
Â Â Â print("SuccessfullyÂ sentÂ email")Â Â Â Â 
exceptÂ Exception:Â Â Â Â 
Â Â Â print("Error:Â unableÂ toÂ sendÂ email")Â Â Â Â 

Python List Comprehension
newlistÂ =Â [expressionÂ forÂ itemÂ inÂ iterableÂ ifÂ conditionÂ ==Â True]Â 

NORMAL
defÂ for_loop(num):Â Â 
Â Â Â Â lÂ =Â []Â Â 
Â Â Â Â forÂ iÂ inÂ range(num):Â Â 
Â Â Â Â Â Â Â Â l.append(iÂ +Â 10)Â Â 
Â Â Â Â returnÂ lÂ 

Using list comprehension
defÂ list_comprehension(num):Â Â 
Â Â Â Â returnÂ [iÂ +Â 10Â forÂ iÂ inÂ range(num)]Â 

Python OS Module

importÂ osÂ Â 
os.mkdir("d:\\newdir")Â 

importÂ osÂ Â Â Â Â 
print(os.getcwd())Â Â Â 

Python Random module
importÂ randomÂ Â 
printÂ (random.randrange(100,Â 500,Â 10))Â Â 

importÂ randomÂ Â 
printÂ (random.choice([50,Â 41,Â 84,Â 40,Â 31]))Â Â 

Python LIst vs Array

???????

Python magic comments
*************************
https://www.educative.io/edpresso/what-is-the-str-method-in-python

Python Stack and Queue
*************************â€¨Stack
A Stack is a data structure that follows the LIFO(Last In First Out) principle. To implement a stack, we need two simple operations
 Push and pop
xÂ =Â ["Python",Â "C",Â "Android"]Â Â Â 
x.push("Java")Â Â Â 
print(x)Â Â 
print(x.pop())Â 

Queue
A Queue follows the First-in-First-Out (FIFO) principle. It is opened from both the ends hence we can easily add elements to the back and can remove elements from the front
importÂ queueÂ Â Â 
LÂ =Â queue.Queue(maxsize=10)Â Â Â 
L.put(9)Â 
print(L.get())Â Â Â 

What is Web Scraping?
Web Scraping is a technique to extract a large amount of data from several websites

* Selenium-Â Selenium is an open-source automated testing library. It is used to check browser activities. To install this library, type the following command in your terminal.
* Pandas
Pandas library is used forÂ data manipulation and analysis. It is used to extract the data and store it in the desired format.
* BeautifulSoup
BeautifulSoup is a Python library that is used to pull data of HTML and XML files. It is mainly designed for web scrapping. It works with the parser to provide a natural way of navigating, searching, and modifying the parse tree. The latest version of BeautifulSoup is 4.8.1
Â Â 
Python Multiprocessing
*************************

Multiprocessing is the ability of the system to run one or more processes in parallel. In simple words, multiprocessing uses the two or moreÂ CPU

within the single computer system

Python
provides the built-in package called multiprocessing which supports swapping processes. Before working with the multiprocessing, we must aware with the process object.

import multiprocessing

def print_cube(num):
	print("Cube: {}".format(num * num * num))
def print_square(num):
	print("Square: {}".format(num * num))
if __name__ == "__main__":
	# creating processes
	p1 = multiprocessing.Process(target=print_square, args=(10, ))
	p2 = multiprocessing.Process(target=print_cube, args=(10, ))
	p1.start()
	p2.start()
	p1.join()
	p2.join()
	print("Done!")

What does the if __name__ == â€œ__main__â€: do? (https://www.youtube.com/watch?v=IeOi4lC_gN4&t=15s/)

Def nam(a, b):
	return a+ b

print(nam(2, 5)

This is our function we used to add two values so we print that 
We run this code our output link 7
Incase  we  want to use that function we import py like

From py_file_name import nam

Print(nam(5, 7)
Without  if  __name__==â€œ__main__:
We print   7 and 12
We use if  __name__==â€œ__main__:
We print 12

Python Decoraters

Python that allows a user to add new functionality to an existing object without modifying its structure.

def div(a,b):
    print (a/b)

def smart_div(func):
    def inner(a,b):
        if a<b:
            a, b =  b,a
        return func(a, b)sx
    return inner
div = smart_div(div)
div(2,4)

Oops Python (https://www.analyticsvidhya.com/blog/2020/09/object-oriented-programming/)
*******************

Class
â€¨A class is a collection of objects or youÂ can say it is a blueprint of objects defining the common attributes and behaviour 
Class name.    ===> two things 
Attributes and behaviour ==> 
Attributes == variables
behaviour == Methods(functions)

Object	

Every thing is a objects ex: dog ,mouse, laptop, persons 

For example, a car can be an object. If we consider the car as an object then its properties would be â€“ its colour, its model, its price, its brand, etc. And its behaviour/function would be acceleration, slowing down, gear change


Inheritance (https://www.youtube.com/watch?v=poMVuz0zndM)

Create a relationship between  parents class and child class called Inheritance
                                                (or)
Deriving the child the class from the parent class

class version1:
    def v1(self):
        print('Button')
        print('text box')
class version2(version1): # Inheritance
    def v2(self):
        print('Drop down list')
if __name__ == '__main__':
    app = version2()
    app.v1()
    app.v2()

Polymorphism (https://www.youtube.com/watch?v=Jp-RjCPx_vA)

Poly = many
Morphism =  different behaviour

class version1:
    def button (self):
       print("colour Red")
class version2(version1):
    def button (self):                                        Method over write.   Same function give different value
        print("colour yellow")
#instantiate objects
a=version2 ()
a.button()


Encapsulation in Python (https://www.youtube.com/watch?v=n5oPKHyJvrU&t=954s)
***********************************

A class is an example of encapsulation as it encapsulates all the data that is member functions,
variables, etc.

Public and private   ===>  use to secure the data

Public 
******
class Bank:
    def ram(self):             #public any one can access
        print("Name:Ram")
        print("A/C No:12345")
        print("Amount:10000")
        print("Address:Salem")
    def sam(self):		 #public any one can access
        print("Name:Sam")                
        print("A/C No:12346")
        print("Amount:15000")
        print("Address:Chennai")
obj=Bank()
obj.ram()

Private
*******
1.class Bank:
    def __init__(self):
        self.__value = 10
    def ram(self):
        print("Name:Ram")
        print("A/C No:12345")
        print("Amount:10000")
        print("Address:Salem")
    def sam(self):
        print("Name:Sam")
        print("A/C No:12346")
        print("Amount:15000")
        print("Address:Chennai")
obj=Bank()
obj.ram()
Print(â€œvalueâ€, obj.value)          # we cont access     so we to change

2.class Bank:
    def __init__(self):
        self.__value = 10
    def ram(self):
        print(self.__value)
        print("Name:Ram")
        print("A/C No:12345")
        print("Amount:10000")
        print("Address:Salem")
obj=Bank()
obj.ram()                                   # now you got that output

3.class Bank:
    def __ram(self):                #new change
        print("Name:Ram")
        print("A/C No:12345")
        print("Amount:10000")
        print("Address:Salem")
    def sam(self):
        print("Name:Sam")
        print("A/C No:12346")
        print("Amount:15000")
        print("Address:Chennai")
obj=Bank()
obj.ram()           # we cont acces

4.class Bank:
    def __init__(self):
        self.__value = 10
    def __ram(self):
        print(self.__value)
        print("Name:Ram")
        print("A/C No:12345")
        print("Amount:10000")
        print("Address:Salem")
    def sam(self):
        self.__ram()                         # now we can access
        print("Name:Sam")
        print("A/C No:12346")
        print("Amount:15000")
        print("Address:Chennai")
obj=Bank()
obj.sam()

Another Method
*****************
class Bank:
    def __ram(self):                        # private function
        print("Name:Ram")
        print("A/C No:12345")
        print("Amount:10000")
        print("Address:Salem")
    def sam(self):
        print("Name:Sam")
        print("A/C No:12346")
        print("Amount:15000")
        print("Address:Chennai")

obj=Bank()
obj._Bank__ram()

Python __init__
*****************

TheÂ __init__Â method is similar toÂ constructorsÂ inÂ C++Â andÂ Java. Constructors are used to initialize the objectâ€™s state 

# A Sample class with init method
class Person:
	# init method or constructor
	def __init__(self, name):
		self.name = name

	# Sample Method
	def say_hi(self):
		print('Hello, my name is', self.name)

p = Person('Nikhil')
p.say_hi()

Python Abstraction(https://www.youtube.com/watch?v=g6nTTPgTCRI&t=28s)
****************************
Abstraction is used to hide the internal functionality of the function
from the users.
The users only interact with the basic implementation of the function,
but inner working is hidden

Internal (process)function ex:pandas is a package ex:Atm

Python JSON

JSON stands forÂ JavaScript Object Notation, which is a widely used data format for data interchange on the web

importÂ jsonÂ Â 
#PythonÂ Â listÂ conversionÂ toÂ JSONÂ Â ArrayÂ Â Â 
print(json.dumps(['Welcome',Â "to",Â "javaTpoint"]))Â Â 
#PythonÂ Â tupleÂ conversionÂ toÂ JSONÂ ArrayÂ Â Â 
print(json.dumps(("Welcome",Â "to",Â "javaTpoint")))Â Â 
#Â PythonÂ stringÂ conversionÂ toÂ JSONÂ StringÂ Â Â 
print(json.dumps("Hello"))Â Â 
#Â PythonÂ intÂ conversionÂ toÂ JSONÂ NumberÂ Â Â 
print(json.dumps(1234))Â Â 
#Â PythonÂ floatÂ conversionÂ toÂ JSONÂ NumberÂ Â Â 
print(json.dumps(23.572))Â Â 
#Â BooleanÂ conversionÂ toÂ theirÂ respectiveÂ valuesÂ Â Â 
print(json.dumps(True))Â Â 
print(json.dumps(False))Â Â 
#Â NoneÂ valueÂ toÂ nullÂ Â Â 
print(json.dumps(None))Â Â Â 

python pydantic

https://betterprogramming.pub/the-beginners-guide-to-pydantic-ba33b26cde89


